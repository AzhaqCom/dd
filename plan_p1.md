# üöÄ Plan P1 - Am√©lioration Compl√®te de l'IA

## üìã **Objectifs P1**

### **Vision globale** 
Transformer l'IA tactique pour que **tous les acteurs** (joueur, compagnons, ennemis) puissent :
1. **Bouger et attaquer librement** dans l'ordre d√©sir√© (r√®gles D&D 5e)
2. **Prendre des d√©cisions tactiques intelligentes** (positionnement, couverture, flanquement)
3. **Avoir des comportements coh√©rents** et pr√©visibles selon leur r√¥le

### **Probl√®mes actuels identifi√©s**
- ‚ùå Gobelin tire √† l'arc mais ne bouge **jamais**
- ‚ùå **7/9 ennemis** sans `aiPriority` ‚Üí Actions tr√®s limit√©es
- ‚ùå **Kael & Finn** sans `aiModifiers` ‚Üí Pas de bonus intelligents  
- ‚ùå **Rhinghann** ne peut pas attaquer au marteau (pas de `melee_attack`)
- ‚ùå Pas de **mouvement tactique** int√©gr√© dans l'IA

---

## üéØ **PHASE 1 - HOMOG√âN√âISATION CRITIQUE (P1.1 ‚Üí P1.4)**

> **Priorit√© absolue** : Standardiser les propri√©t√©s IA pour tous les acteurs

### **P1.1 - Homog√©n√©isation Companions** üèÉ‚Äç‚ôÇÔ∏è *URGENT*

#### **P1.1a - KAEL : Compl√©ter l'IA**
```javascript
// AJOUTER dans companions.js
aiModifiers: {
  "ranged_attack": {
    safeDistanceBonus: +35,     // Maintenir distance archer
    lowHPTargetBonus: +25,      // Finir ennemis bless√©s
    coverBonus: +30,            // Utiliser couverture  
    elevationBonus: +20         // Position sur√©lev√©e
  },
  "support_skill": {
    allyInDangerBonus: +40,     // Aider alli√© en difficult√©
    scoutingBonus: +20,         // Reconnaissance/surveillance
    trapDetectionBonus: +30     // D√©tecter pi√®ges
  }
}
```

#### **P1.1b - FINN : Compl√©ter l'IA**
```javascript  
// AJOUTER dans companions.js
aiModifiers: {
  "support_skill": {
    inventionBonus: +50,        // Gadgets/inventions
    allyEquipmentBonus: +30,    // R√©parer √©quipement
    detectionBonus: +40,        // Analyse/d√©tection
    environmentalBonus: +25     // Exploiter environnement
  },
  "ranged_attack": {
    precisionBonus: +25,        // Tir de pr√©cision
    weakSpotBonus: +35,         // Exploiter faiblesses
    technicalBonus: +20         // Armes technologiques
  },
  "heal": {
    mechanicalHealBonus: +20,   // Soins gadgets/m√©caniques
    emergencyRepairBonus: +30   // R√©paration d'urgence
  }
}
```

#### **P1.1c - RHINGANN : Ajouter combat au marteau**
```javascript
// MODIFIER aiPriority dans companions.js
aiPriority: ["heal", "melee_attack", "buff", "ranged_support"]

// AJOUTER dans aiModifiers
"melee_attack": {
  noHealNeededBonus: +60,     // Attaquer si personne √† soigner  
  finishingBlowBonus: +40,    // Achever ennemi bless√©
  protectAllyBonus: +50,      // D√©fendre alli√© corps-√†-corps
  divineSmiteBonus: +35       // Utiliser capacit√©s divines
}
```

---

### **P1.2 - Homog√©n√©isation Enemies** üßå *URGENT*

#### **Strat√©gie** : Ajouter propri√©t√©s IA dans `EnemyFactory.js` pour √©viter de surcharger `enemies.js`

#### **P1.2a - EnemyFactory : Auto-g√©n√©ration IA**
```javascript
// AJOUTER dans EnemyFactory.createEnemyFromTemplate()
static generateAIForEnemy(template) {
  // Si l'ennemi a d√©j√† une IA compl√®te, la garder
  if (template.aiPriority && template.aiModifiers) {
    return { aiPriority: template.aiPriority, aiModifiers: template.aiModifiers }
  }
  
  // Sinon g√©n√©rer selon le r√¥le
  const aiByRole = {
    'brute': {
      aiPriority: ['melee_attack', 'charge', 'intimidate'],
      aiModifiers: {
        'melee_attack': { closestTargetBonus: +40, lowHPBonus: +25 },
        'charge': { isolatedTargetBonus: +35 },
        'intimidate': { multipleEnemiesBonus: +30 }
      }
    },
    'skirmisher': {
      aiPriority: ['hit_and_run', 'ranged_attack', 'melee_attack'],
      aiModifiers: {
        'hit_and_run': { isolatedTargetBonus: +40, escapeRouteBonus: +30 },
        'ranged_attack': { safeDistanceBonus: +35, coverBonus: +25 },
        'melee_attack': { corneredBonus: +40, flankedTargetBonus: +30 }
      }
    },
    'caster': {
      aiPriority: ['ranged_spell', 'area_damage', 'debuff'],
      aiModifiers: {
        'ranged_spell': { multipleTargetsBonus: +50, safeDistanceBonus: +40 },
        'area_damage': { groupedEnemiesBonus: +60 },
        'debuff': { strongEnemyBonus: +35 }
      }
    }
  }
  
  return aiByRole[template.role] || aiByRole['brute'] // Fallback
}
```

#### **P1.2b - Application aux 7 ennemis manquants**
- **Ombre** ‚Üí `skirmisher` (furtif, mobilit√©)
- **Molosse** ‚Üí `brute` (charge, morsure)  
- **M√©phite** ‚Üí `skirmisher` (vol, harc√®lement)
- **Kobold** ‚Üí `skirmisher` (petit, agile)
- **Goule** ‚Üí `brute` (paralysie, contact)
- **Squelette** ‚Üí `brute` (basique, contact) 
- **Diablotin** ‚Üí `caster` (sorts, vol)

---

## ‚öîÔ∏è **PHASE 2 - MOUVEMENT TACTIQUE (P1.3 ‚Üí P1.5)**

> **Innovation majeure** : Int√©grer d√©placement + action dans l'IA

### **P1.3 - Architecture Mouvement + Action**

#### **P1.3a - Nouveau syst√®me de "TurnPlan"**
```javascript
// Nouvelle structure dans EntityAI_Hybrid
class TurnPlan {
  constructor() {
    this.phases = []  // Array de phases : move, action, move
    this.totalScore = 0
  }
  
  addPhase(type, details) {
    // type: 'move', 'attack', 'spell', 'end_turn'
    this.phases.push({ type, ...details })
  }
}

// Exemple de plan complet
const turnPlan = new TurnPlan()
turnPlan.addPhase('move', { to: { x: 8, y: 5 }, reason: 'get_in_range' })
turnPlan.addPhase('attack', { attack: 'arc_court', target: player })
turnPlan.addPhase('move', { to: { x: 12, y: 7 }, reason: 'take_cover' })
```

#### **P1.3b - √âvaluation tactique des positions**
```javascript
// Dans EntityAI_Hybrid - nouvelles m√©thodes
static evaluatePosition(entity, position, gameState) {
  let score = 0
  
  // Bonus couverture
  if (hasPartialCover(position)) score += 20
  if (hasFullCover(position)) score += 40
  
  // Bonus √©l√©vation
  if (isElevated(position)) score += 15
  
  // Malus exposition
  const threateningEnemies = countThreateningEnemies(entity, position, gameState)
  score -= threateningEnemies * 25
  
  // Bonus position tactique selon r√¥le
  if (entity.role === 'skirmisher') {
    score += hasEscapeRoute(position) ? 30 : -20
  }
  
  return score
}

static planMovementAndAction(entity, gameState) {
  const possiblePlans = []
  
  // Plan 1: Attaquer puis bouger
  const attackThenMove = this.evaluateAttackThenMove(entity, gameState)
  if (attackThenMove) possiblePlans.push(attackThenMove)
  
  // Plan 2: Bouger puis attaquer
  const moveThenAttack = this.evaluateMoveThenAttack(entity, gameState)
  if (moveThenAttack) possiblePlans.push(moveThenAttack)
  
  // Plan 3: Double mouvement (repli/charge)
  const doubleMovement = this.evaluateDoubleMovement(entity, gameState)
  if (doubleMovement) possiblePlans.push(doubleMovement)
  
  // Retourner le meilleur plan
  return possiblePlans.sort((a, b) => b.totalScore - a.totalScore)[0]
}
```

### **P1.4 - Int√©gration Mouvement D&D 5e**

#### **P1.4a - R√®gles de d√©placement**
- **Vitesse standard** : 30 pieds (6 cases)
- **Action Dash** : Double le mouvement (12 cases)
- **Terrain difficile** : Co√ªt double
- **Attaque d'opportunit√©** : Quitter case adjacente

#### **P1.4b - Types de mouvements tactiques**
```javascript
const MOVEMENT_TACTICS = {
  'get_in_range': {
    priority: +40,
    condition: (entity, target) => getDistance(entity, target) > attackRange
  },
  'take_cover': {
    priority: +30,
    condition: (entity) => entity.currentHP < entity.maxHP * 0.5
  },
  'flank_target': {
    priority: +35,  
    condition: (entity, target) => canFlank(entity, target)
  },
  'escape_melee': {
    priority: +50,
    condition: (entity) => isInMelee(entity) && entity.role === 'caster'
  },
  'charge_target': {
    priority: +45,
    condition: (entity, target) => entity.role === 'brute' && getDistance(entity, target) > 1
  }
}
```

---

## üß† **PHASE 3 - IA AVANC√âE (P1.5 ‚Üí P1.8)**

### **P1.5 - Comportements Sp√©cialis√©s par R√¥le**

#### **Tank (Tyrion)** 
- **Positionnement** : Front line, protection alli√©s
- **Mouvement** : Intercepter ennemis, bloquer passages
- **D√©cisions** : Taunt les plus dangereux, protection priorit√© healers

#### **Healer (Rhingann)**
- **Positionnement** : Arri√®re, mais port√©e de soin
- **Mouvement** : Maintenir ligne de vue alli√©s, √©viter ennemis
- **D√©cisions** : Soin d'urgence > marteau si s√©curis√©

#### **Archer (Kael)**  
- **Positionnement** : √âl√©vation, couverture, champ de tir
- **Mouvement** : Kite, maintenir distance optimale
- **D√©cisions** : Cibles prioritaires (casters ennemis, low HP)

#### **Support (Finn)**
- **Positionnement** : Flexible selon besoins
- **Mouvement** : Adaptation situationnelle  
- **D√©cisions** : Gadgets tactiques, assistance cibl√©e

#### **DPS (Zara)**
- **Positionnement** : Distance s√©curis√©e, angles AoE
- **Mouvement** : Optimiser zones d'effet
- **D√©cisions** : Sorts AoE > Single target > Control

### **P1.6 - IA Ennemis Sp√©cialis√©e**

#### **Skirmisher (Gobelin, Kobold)**
```javascript
// Comportement hit-and-run am√©lior√©
aiPriority: ['evaluate_battlefield', 'hit_and_run', 'ranged_attack', 'retreat']

planTurn(entity, gameState) {
  // 1. √âvaluer si on peut faire hit-and-run
  if (canReachAndRetreat(entity, targets)) {
    return createHitAndRunPlan(entity, bestTarget)
  }
  
  // 2. Sinon tir √† distance depuis position s√ªre
  if (isInSafePosition(entity)) {
    return createRangedAttackPlan(entity, bestTarget)  
  }
  
  // 3. Sinon se repositionner
  return createRepositionPlan(entity, gameState)
}
```

#### **Brute (Molosse, Goule)**
```javascript
// Comportement charge et contact
aiPriority: ['charge_weakest', 'melee_attack', 'intimidate']

planTurn(entity, gameState) {
  const weakestTarget = findWeakestAccessibleTarget(entity, gameState)
  
  // Charger la cible la plus faible accessible
  if (weakestTarget && canCharge(entity, weakestTarget)) {
    return createChargePlan(entity, weakestTarget)
  }
  
  return createMeleeAttackPlan(entity, getBestTarget(entity, gameState))
}
```

### **P1.7 - Syst√®me de Menace Dynamique**

#### **Threat Assessment**
```javascript
static calculateThreatLevel(entity, target, gameState) {
  let threat = 0
  
  // Facteurs offensifs
  threat += (target.maxHP / entity.maxHP) * 30
  threat += target.ac > entity.averageAttackBonus ? 20 : 0
  
  // Facteurs situationnels  
  if (target.type === 'player') threat += 40
  if (target.role === 'healer') threat += 35
  if (target.currentHP < target.maxHP * 0.3) threat += 25 // Cible facile
  
  // Distance et accessibilit√©
  const distance = getDistance(entity, target)
  threat -= Math.min(distance * 5, 30) // Plus loin = moins mena√ßant
  
  return threat
}
```

---

## üõ†Ô∏è **PHASE 4 - INT√âGRATION TECHNIQUE (P1.9 ‚Üí P1.11)**

### **P1.8 - Refactoring CombatAI**

#### **Nouvelle architecture CombatAI**
```javascript
// CombatAI devient coordinateur de TurnPlanner
static executeEntityTurn(entity, gameState, callbacks) {
  // 1. PLANIFICATION COMPL√àTE DU TOUR
  const turnPlan = EntityAI_Hybrid.planCompleteTurn(entity, gameState)
  
  if (!turnPlan || turnPlan.phases.length === 0) {
    return this.handleNoActionAvailable(entity, callbacks)
  }
  
  // 2. EX√âCUTION S√âQUENTIELLE DES PHASES
  this.executeTurnPlan(entity, turnPlan, gameState, callbacks)
}

static async executeTurnPlan(entity, turnPlan, gameState, callbacks) {
  for (const phase of turnPlan.phases) {
    switch (phase.type) {
      case 'move':
        await this.executeMovement(entity, phase, gameState, callbacks)
        break
      case 'attack':
      case 'spell':  
        await this.executeAction(entity, phase, gameState, callbacks)
        break
    }
    
    // D√©lai entre phases pour animation
    await this.delay(500)
  }
  
  // Fin du tour
  callbacks.onNextTurn()
}
```

### **P1.9 - Interface Mouvement**

#### **Int√©gration avec CombatGrid**
```javascript
// Nouveau syst√®me de mouvement visuel
static async executeMovement(entity, movePhase, gameState, callbacks) {
  const fromPos = getCurrentPosition(entity, gameState)
  const toPos = movePhase.to
  
  // Animation de d√©placement
  await this.animateMovement(entity, fromPos, toPos, callbacks.onMessage)
  
  // Mise √† jour positions
  gameState.combatPositions[entity.id || entity.name] = toPos
  
  // V√©rifier attaques d'opportunit√©
  const opportunityAttacks = this.checkOpportunityAttacks(entity, fromPos, toPos, gameState)
  if (opportunityAttacks.length > 0) {
    await this.handleOpportunityAttacks(opportunityAttacks, callbacks)
  }
}
```

---

## üìä **CALENDRIER D'EX√âCUTION**

### **Sprint 1 (2-3 jours) : Homog√©n√©isation**
- [ ] P1.1 - Compl√©ter aiModifiers Kael, Finn, Rhingann  
- [ ] P1.2 - Auto-g√©n√©ration IA dans EnemyFactory
- [ ] Tests : Tous les acteurs ont des comportements de base

### **Sprint 2 (3-4 jours) : Mouvement Tactique Base** 
- [ ] P1.3 - Syst√®me TurnPlan 
- [ ] P1.4 - R√®gles mouvement D&D 5e
- [ ] Tests : Entities peuvent bouger puis attaquer

### **Sprint 3 (4-5 jours) : IA Avanc√©e**
- [ ] P1.5 - Comportements sp√©cialis√©s par r√¥le
- [ ] P1.6 - IA ennemis intelligente  
- [ ] P1.7 - Threat assessment
- [ ] Tests : IA tactique fonctionnelle

### **Sprint 4 (2-3 jours) : Int√©gration Finale**
- [ ] P1.8 - Refactoring CombatAI
- [ ] P1.9 - Interface mouvement
- [ ] Tests complets et optimisation

---

## üéØ **Crit√®res de Succ√®s P1**

### **Fonctionnalit√©s**
- ‚úÖ Gobelin effectue hit-and-run (bouge + attaque + se replie)
- ‚úÖ Rhinghann utilise son marteau quand personne √† soigner
- ‚úÖ Kael se positionne tactiquement (√©l√©vation, couverture)  
- ‚úÖ Tous les ennemis ont des comportements distinctifs
- ‚úÖ Joueur peut choisir ordre mouvement/action

### **Technique**  
- ‚úÖ 0 erreur console pendant 10min de combat
- ‚úÖ Tous les acteurs ont aiPriority + aiModifiers
- ‚úÖ Performance fluide (pas de lag IA)
- ‚úÖ Architecture modulaire et maintenable

### **Exp√©rience Utilisateur**
- ‚úÖ Combat semble "intelligent" et impr√©visible
- ‚úÖ Diff√©rences visibles entre r√¥les d'IA  
- ‚úÖ Joueur a contr√¥le total de son tour
- ‚úÖ Animations fluides et compr√©hensibles

---

*Plan P1 cr√©√© suite √† l'analyse compl√®te des probl√®mes P0 et des besoins d'am√©lioration tactique. Focus sur homog√©n√©isation puis innovation mouvement.*

permettre au joueur de bouger apres avoir attaquer