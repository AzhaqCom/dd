import React, { useState, useEffect } from 'react';
import { useGameStore } from '../../stores/gameStore';
import { useCharacterStore } from '../../stores/characterStore';
import { SceneManager } from '../../services/SceneManager';
import { ProceduralGenerator } from '../../services/ProceduralGenerator';
import './HubScene.css';

/**
 * Composant pour le rendu des sc√®nes de hub interactif
 */
export const HubScene = ({ scene, onChoice, onAction }) => {
  const [currentEncounter, setCurrentEncounter] = useState(null);
  const [explorationState, setExplorationState] = useState('exploring');
  const [discoveredElements, setDiscoveredElements] = useState([]);
  const [originalHubId, setOriginalHubId] = useState(scene.id); // M√©moriser l'ID du hub d'origine
  const { playerCharacter } = useCharacterStore();
  const { addCombatMessage, setFlag } = useGameStore();

  // Extraire les donn√©es d'exploration de la sc√®ne
  const explorationData = scene.exploration || {};
  const { encounters = [], npcs = [], rewards = [], biome = 'unknown' } = explorationData;

  useEffect(() => {
    console.log('üé≤ HubScene mont√©e:', { 
      sceneId: scene.id, 
      biome, 
      explorationData,
      sceneComplete: scene
    });

    // Si on revient d'un combat avec un choix "return_to_hub", rester dans le hub
    if (scene.id === 'return_to_hub' || scene.choices?.some(choice => choice.next === 'return_to_hub')) {
      console.log('üîÑ Signal de retour au hub d√©tect√©, maintien de l\'√©tat');
      // On reste dans l'√©tat d'exploration actuel
    }
  }, [scene.id]);

  const handleExploreAction = () => {
    console.log('üîç Action d\'exploration d√©clench√©e');
    
    // G√©n√©rer directement du contenu proc√©dural selon le type d'exploration
    const explorationTypes = ['combat', 'dialogue', 'discovery'];
    const selectedType = ProceduralGenerator.selectRandom(explorationTypes);
    
    console.log(`üé≤ Type d'exploration s√©lectionn√©: ${selectedType}`);
    
    let generatedContent;
    
    if (selectedType === 'combat') {
      generatedContent = ProceduralGenerator.generateCombatScene('random_encounter', {
        biome: biome,
        difficulty: 'medium',
        playerLevel: playerCharacter?.level || 1,
        currentHubId: scene.id // Passer l'ID du hub actuel (proc√©dural)
      });
    } else if (selectedType === 'dialogue') {
      generatedContent = ProceduralGenerator.generateDialogueScene('random_meeting', {
        biome: biome
      });
    } else {
      generatedContent = ProceduralGenerator.generateTextScene('exploration_result', {
        biome: biome,
        location: scene.id
      });
    }
    
    console.log('‚ú® Contenu proc√©dural g√©n√©r√©:', generatedContent);
    
    // Si c'est un combat, lancer la sc√®ne directement
    if (selectedType === 'combat') {
      onChoice({ 
        text: 'Lancer l\'exploration de combat', 
        next: generatedContent.id,
        generatedScene: generatedContent
      });
    } else {
      // Sinon, afficher dans l'interface d'encounter
      setCurrentEncounter({
        content: generatedContent.content,
        choices: generatedContent.choices,
        npc: generatedContent.npc
      });
      setExplorationState('encounter');
    }
    
    // Ajouter √† la liste des √©l√©ments d√©couverts
    setDiscoveredElements(prev => [...prev, {
      type: selectedType,
      data: generatedContent,
      timestamp: Date.now()
    }]);
  };

  const handleEncounterResolution = (result) => {
    console.log('‚úÖ R√©solution de rencontre:', result);
    
    // Appliquer les r√©sultats (XP, items, etc.)
    if (result.experience) {
      console.log(`üí´ +${result.experience} XP gagn√© !`);
      addCombatMessage(`üí´ +${result.experience} XP gagn√© !`, 'experience');
      setFlag('lastExplorationReward', `${result.experience} XP`);
    }
    
    if (result.items) {
      console.log('üéÅ Items obtenus:', result.items);
      addCombatMessage(`üéÅ Trouv√©: ${result.items.join(', ')}`, 'reward');
      setFlag('lastItemsFound', result.items.join(', '));
    }
    
    // Ajouter l'√©v√©nement aux d√©couvertes si c'est significatif
    if (result.experience || result.items) {
      setDiscoveredElements(prev => [...prev, {
        type: result.experience ? 'reward' : 'discovery',
        data: {
          experience: result.experience,
          items: result.items,
          timestamp: Date.now()
        },
        timestamp: Date.now()
      }]);
    }
    
    // Retourner √† l'exploration
    setCurrentEncounter(null);
    setExplorationState('exploring');
  };

  const handleNPCInteraction = (npc) => {
    console.log('üí¨ Interaction avec PNJ:', npc);
    
    // G√©n√©rer un dialogue simple
    setCurrentEncounter({
      content: {
        title: `Conversation avec ${npc?.name || 'un inconnu'}`,
        text: `${npc?.name || 'L\'inconnu'} vous regarde. "${npc?.defaultDialogue || 'Bonjour, voyageur. Que puis-je faire pour vous ?'}"`
      },
      choices: [
        { text: 'Demander des informations sur la r√©gion', action: 'ask_info' },
        { text: 'Proposer un √©change', action: 'trade' },
        { text: 'Saluer et partir', action: 'leave' }
      ]
    });
    
    setExplorationState('dialogue');
  };

  const handleContinueJourney = () => {
    console.log('‚û°Ô∏è Continuer le voyage');
    // Retourner √† la narration principale
    onChoice({ text: 'Continuer', next: 'continue_journey' });
  };

  // Fonction sp√©ciale pour g√©rer les retours au hub depuis d'autres sc√®nes
  const handleReturnToHub = () => {
    console.log('üîÑ Retour au hub d\'origine:', originalHubId);
    // Rediriger vers la sc√®ne hub d'origine
    onChoice({ text: 'Retour au hub', next: originalHubId });
  };

  // Rendu des diff√©rents √©tats d'exploration
  const renderExplorationInterface = () => (
    <div className="exploration-interface">
      <div className="exploration-header">
        <h3>üó∫Ô∏è {scene.content?.title || 'Zone d\'Exploration'}</h3>
        <div className="biome-indicator">
          <span className="biome-badge">{getBiomeIcon(biome)} {biome}</span>
        </div>
      </div>

      <div className="exploration-description">
        <p>{scene.content?.text}</p>
      </div>

      <div className="exploration-actions">
        <div className="action-grid">
          <button 
            className="exploration-btn explore"
            onClick={handleExploreAction}
            disabled={explorationState !== 'exploring'}
          >
            üîç Explorer la zone
          </button>

          {npcs.length > 0 && (
            <button 
              className="exploration-btn npc"
              onClick={() => handleNPCInteraction(npcs[0])}
            >
              üí¨ Approcher {npcs[0]?.name || 'quelqu\'un'}
            </button>
          )}

          {encounters.length > 0 && (
            <button 
              className="exploration-btn encounter"
              onClick={() => {
                console.log('‚öîÔ∏è Enqu√™te sur les traces d√©clench√©e');
                setCurrentEncounter({
                  content: {
                    title: 'Traces Suspectes',
                    text: 'En examinant attentivement les traces, vous d√©couvrez...'
                  },
                  choices: [
                    { text: 'Suivre les traces', action: 'follow_tracks' },
                    { text: 'Retourner √† l\'exploration', action: 'back' }
                  ]
                });
                setExplorationState('encounter');
              }}
            >
              ‚öîÔ∏è Enqu√™ter sur les traces
            </button>
          )}

          <button 
            className="exploration-btn continue"
            onClick={handleContinueJourney}
          >
            ‚û°Ô∏è Continuer son chemin
          </button>
        </div>
      </div>

      {discoveredElements.length > 0 && (
        <div className="discovered-elements">
          <h4>üèõÔ∏è D√©couvertes</h4>
          <div className="discoveries-list">
            {discoveredElements.map((element, index) => (
              <div key={index} className="discovery-item">
                <span className="discovery-type">{getDiscoveryIcon(element.type)}</span>
                <span className="discovery-description">
                  {element.data?.content?.title || '√âl√©ment d√©couvert'}
                </span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );

  const renderEncounter = () => (
    <div className="encounter-view">
      <div className="encounter-header">
        <h3>‚ö° Rencontre</h3>
        <button 
          className="back-btn"
          onClick={() => handleEncounterResolution({})}
        >
          ‚Üê Retour √† l'exploration
        </button>
      </div>

      <div className="encounter-content">
        <h4>{currentEncounter?.content?.title}</h4>
        <p>{currentEncounter?.content?.text}</p>

        <div className="encounter-choices">
          {currentEncounter?.choices?.map((choice, index) => (
            <button
              key={index}
              className="choice-btn"
              onClick={() => {
                console.log('üé¨ Choix s√©lectionn√©:', choice);
                
                // Actions sp√©cifiques selon le choix
                if (choice.action === 'back' || choice.action === 'leave') {
                  handleEncounterResolution({});
                } else if (choice.action === 'follow_tracks') {
                  // Nouvelle rencontre bas√©e sur le choix
                  setCurrentEncounter({
                    content: {
                      title: 'En Suivant les Traces',
                      text: 'Les traces vous m√®nent √† une clairi√®re o√π des bandits ont √©tabli un camp...'
                    },
                    choices: [
                      { text: 'Attaquer par surprise', action: 'attack' },
                      { text: 'Observer discr√®tement', action: 'observe' },
                      { text: 'Faire demi-tour', action: 'back' }
                    ]
                  });
                } else if (choice.action === 'ask_info') {
                  // G√©n√©rer une sc√®ne de dialogue proc√©durale
                  console.log('üí¨ G√©n√©ration proc√©durale du dialogue informatif');
                  
                  const dialogueScene = ProceduralGenerator.generateDialogueScene('info_request', {
                    biome: biome,
                    npc: currentEncounter.npc || { name: 'Inconnu', role: 'local' }
                  });
                  
                  setCurrentEncounter({
                    content: dialogueScene.content,
                    choices: dialogueScene.choices
                  });
                } else if (choice.action === 'attack') {
                  // G√©n√©rer une sc√®ne de combat proc√©durale !
                  console.log('‚öîÔ∏è G√©n√©ration proc√©durale du combat contre les bandits !');
                  
                  const combatScene = ProceduralGenerator.generateCombatScene('bandit_ambush', {
                    biome: biome,
                    difficulty: 'medium',
                    surprise: true,
                    playerLevel: playerCharacter?.level || 1,
                    currentHubId: scene.id // Passer l'ID du hub actuel (proc√©dural)
                  });
                  
                  console.log('‚ú® Sc√®ne de combat g√©n√©r√©e:', combatScene);
                  
                  // Utiliser onChoice pour lancer la sc√®ne de combat g√©n√©r√©e
                  onChoice({ 
                    text: 'Lancer le combat', 
                    next: combatScene.id,
                    generatedScene: combatScene // Passer la sc√®ne g√©n√©r√©e
                  });
                  
                } else if (choice.action === 'observe') {
                  // Action d'observation
                  setCurrentEncounter({
                    content: {
                      title: 'Observation Discr√®te',
                      text: 'Vous observez le camp depuis les buissons. Vous comptez 3 bandits autour d\'un feu. L\'un d\'eux semble porter une bourse bien remplie...'
                    },
                    choices: [
                      { text: 'Attaquer maintenant', action: 'attack' },
                      { text: 'Attendre la nuit', action: 'wait_night' },
                      { text: 'Partir discr√®tement', action: 'back' }
                    ]
                  });
                  
                } else {
                  // R√©solution g√©n√©rique
                  const mockResult = {
                    experience: 25,
                    items: ['souvenir_exploration']
                  };
                  handleEncounterResolution(mockResult);
                }
              }}
            >
              {choice.text}
            </button>
          ))}
        </div>
      </div>
    </div>
  );

  // Rendu principal selon l'√©tat
  return (
    <div className="exploration-scene">
      {explorationState === 'exploring' && renderExplorationInterface()}
      {explorationState === 'encounter' && currentEncounter && renderEncounter()}
      
      {explorationState === 'dialogue' && currentEncounter && renderEncounter()}
    </div>
  );
};

// Utilitaires d'affichage
const getBiomeIcon = (biome) => {
  const icons = {
    forest: 'üå≤',
    village: 'üèòÔ∏è',
    dungeon: 'üè∞',
    mountain: '‚õ∞Ô∏è',
    wilderness: 'üåø',
    unknown: '‚ùì'
  };
  return icons[biome] || icons.unknown;
};

const getDiscoveryIcon = (type) => {
  const icons = {
    encounter: '‚öîÔ∏è',
    npc: 'üë§',
    treasure: 'üíé',
    secret: 'üîç'
  };
  return icons[type] || '‚ú®';
};

export default HubScene;